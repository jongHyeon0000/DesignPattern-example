# BluetoothSupport

## 디폴트 메서드

**왜 디폴트 메서드라는 문법이 생겼을까?**
> 디폴트 메서드라는 문법이 등장하기 전(Java 8)에는 인터페이스(interface)를 구현한 클래스(Concrete Class)의 구조를 깨뜨리지 않고서는  
> 인터페이스에 새 기능을 하는 메서드를 추가 할 방법이 없었다.  
> 살펴보자, BluetoothSupport 인터페이스의 예전 버전에서는 자동으로 페어링을 해주는 autoPairing이란 기능이 없었다.
> 하지만 이제 BluetoothSupport 인터페이스는 autoPairing 기능까지 지원해야 한다.   
> 
> 디폴트 메서드라는 문법이 없었다면 BluetoothSupport를 구현한 모든 클래스에서 에러 메시지가 마구 나왔을 것이다.  
> 거기다 만약 자회사 제품이 autoPairing 기능을 절대 구현할 수 없는 구조로 이미 만들어 졌다면, 소프트웨어팀의 부담은 가중된다.  
> 구현 클래스는 디폴트 메서드를 구현(문법 상으론 재정의, overriding)하지 않아도 되며, 구현 하지 않을 경우 인터페이스에 정의된 디폴트 구현
> 이 쓰이게 된다.  
> 따라서 이미 폭넓게 사용되고 있는 인터페이스의 구조를 변경하거나, 새로운 기능을 추가할 때 기존 구체 클래스 와의 호환성 문제에서 조금이나마 해방되게 된다.   

**문제는 자바 7까지의 세상은 "현재의 인터페이스에 새로운 메서드가 추가될 일은 영원히 없다" 라고 생각한다는 것이다.**

전달하고 싶은 내용은 디폴트 메서드가 나쁜 문법도 아니고, 위험한 문법도 아니지만 여전히 인터페이스 설계, 수정은 세심한 주의가 필요하다는 것이다.

특히 컬렉션 인터페이스들이 람다식의 활용을 위해 람다식을 파라미터로 받는 디폴트 메서드가 많이 생겼는데, 아래 내용은 디폴트 메서드가 호환성 해결에 만능이 아니라는 것을 보여주는 글이다.

>Collection 인터페이스의 removeIf 메서드를 살펴보자.  
이 메서드는 Predicate 형식의 함수형 인터페이스 규격에 맞는 람다식을 입력받는다.  
컬렉션의 원소를 iterator로 하나 하나 순회하면서, 원소 하나 하나 파라미터로 입력받은 람다식을 실행한다.  
만약 해당 람다식이 true를 반환하면 해당 원소를 삭제한다.  

이제 아래 내용을 읽어보자.

>아파치에서는 SynchronizedCollection 클래스가 있다.  
기존 자바 컬렉션에 멀티 쓰레드 웹 개발 환경을 위해 클라이언트가 제공한 객체로 락(lock)을 거는 능력을 추가로 제공한다.  
사실 SynchronizedCollection는 기존 자바 컬렉션을 그대로 사용한다. 대신 락을 거는 기능을 추가해 똑같은 기능을 감싸기만 했다.(래퍼 클래스, wrapper class)  
>
>하지만 SynchronizedCollection은 removeIf 라는 디폴트 메서드가 생긴 것을 꿈에도 몰랐고, 
>자바의 removeIf는 당연히 멀티 쓰레드 환경에서의 동기화 문제 까지는 고려하지 않았다.  
>
>removeIf 메서드를 정상적인 기능 수행을 위해 디폴트 메서드라 할지라도 재정의 해야 하지만(여기서는 동기화 이슈), 디폴트 메서드는 구현이 강제되지 않으므로 알 길이 없었다.  
>결국 클래스의 불변식이 디폴트 메서드 호출 하나만으로 깨져버렸다.

이펙티브 자바에서는 기존 인터페이스에 디폴트 메서드를 추가할 때 마주치게 될 이슈와 트러블 슈팅들에 대해 얘기하고 있다.
  
생각보다 심오한 내용이지만, 인터페이스를 주로 구현하여 사용하던 기존 구현 클래스의 상황을 고려하는 것이 핵심이다.  
가장 좋은 대안은 인터페이스를 상속 받는 구현체를 API 개발자가 임의로 3개정도 만들어서 예시로 구현을 해 보는 것이다.  
인터페이스를 설계 할 때 가져야 할 덕목들에 대한 이야기가 많다. 자세한 내용은 item 22, 23을 참조하자.