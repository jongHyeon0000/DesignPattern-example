# BluetoothSupport

## 디폴트 메서드

### **왜 디폴트 메서드라는 문법이 생겼을까?**
 디폴트 메서드라는 문법이 등장하기 전(Java 8)에는 인터페이스(interface)를 구현한 클래스(Concrete Class)의 구조를 깨뜨리지 않고서는 인터페이스에 새 기능을 하는 메서드를 추가 할 방법이 없었다.  

 한번 상상해보자, BluetoothSupport 인터페이스의 예전 버전에서는 자동으로 페어링을 해주는 autoPairing이란 기능이 없었다.  

하지만 이제 BluetoothSupport 인터페이스는 autoPairing 기능까지 지원해야 한다.   
 
디폴트 메서드라는 문법이 없었다면 BluetoothSupport를 구현한 모든 클래스에서 에러 메시지가 마구 나왔을 것이다.  
거기다 만약 자회사 제품이 autoPairing 기능을 절대 구현할 수 없는 구조로 이미 만들어 졌다면, 계층구조나 코드의 큰 수정이 필요 할 수도 있다.  

인터페이스를 구현한 클래스는 디폴트 메서드를 재정의(overriding)하지 않아도 되며, 구현 하지 않을 경우 인터페이스에 정의된 디폴트 구현 이 쓰이게 된다.  

따라서 이미 폭넓게 사용되고 있는 인터페이스의 구조를 변경하거나, 새로운 기능을 추가할 때 기존 구체 클래스 와의 호환성 문제에서 조금이나마 해방되게 된다.   

### **문제는 자바 7까지의 세상은 "현재의 인터페이스에 새로운 메서드가 추가될 일은 영원히 없다" 라고 생각한다는 것이다.**

전달하고 싶은 내용은 디폴트 메서드가 나쁜 문법은 아니지만 여전히 인터페이스 설계, 수정은 세심한 주의가 필요하다는 것이다.

특히 컬렉션 인터페이스들이 람다 식의 활용을 위해 람다 식을 파라미터로 받는 디폴트 메서드가 많이 생겼는데, 아래 내용은 디폴트 메서드가 호환성 해결에 만능이 아니라는 것을 보여주는 글이다.

    Collection 인터페이스의 removeIf 메서드를 살펴보자.  
    이 메서드는 Predicate 형식의 함수형 인터페이스 규격에 맞는 람다식을 입력받는다.  
    컬렉션의 원소를 iterator로 하나 하나 순회하면서, 원소 하나 하나 파라미터로 입력받은 람다식을 실행한다.  
    만약 해당 람다식이 true를 반환하면 해당 원소를 삭제한다.  

이제 아래 내용을 읽어보자.

    아파치에서는 SynchronizedCollection 클래스가 있다.  
    기존 자바 컬렉션에 멀티 쓰레드 웹 개발 환경을 위해 클라이언트가 제공한 객체로  
    락(lock)을 거는 능력을 추가로 제공한다.  
    사실 SynchronizedCollection는 기존 자바 컬렉션을 그대로 인스턴스로 사용한다.  
    대신 락을 거는 새로운 기능으로 인스턴스를 감싸기만 했다.(래퍼 클래스, wrapper class)  

    하지만 SynchronizedCollection은 removeIf 라는 디폴트 메서드가 생긴 것을 꿈에도 몰랐고, 
    자바의 removeIf 메서드는 당연히 SynchronizedCollection의 존재를 고려하지 않았다.  

SynchronizedCollection 클래스는 removeIf 메서드가 디폴트 메서드라 할지라도 재정의 해야 했다.하지만 디폴트 메서드는 구현이 강제되지 않으므로 알 길이 없었다.  

결국 클래스의 불변식이 디폴트 메서드 호출 하나만으로 깨져버렸다.

    이펙티브 자바에서는 기존 인터페이스에 디폴트 메서드를 추가할 때 마주치게 될 이슈와  
    트러블 슈팅들에 대해 얘기하고 있다.
      
    내가 만든 인터페이스를 구현하여 사용하던 기존 구체 클래스가 이번 릴리즈로 어떤 상황에 처해질 지 고려하는 내용이 핵심 내용이다.  
    또 실제 회사에서 스터디 중 가장 많이 나오는 주제가 "추상 클래스 vs 인터페이스" 인데  
    사실 정답은 없는 고민이지만 다양한 설계 기법과 사고방식을 제시해준다.  